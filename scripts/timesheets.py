#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#   "requests<3",
# ]
# ///

import argparse
import json
import os
import sys
from datetime import date, timedelta

import requests

# Configuration
GITLAB_USER = "manuelpland"
HARVEST_ACCOUNT_ID = "147488"
HARVEST_USER_ID = "5087166"
HARVEST_PROJECT_ID = "44185352"  # Palma
HARVEST_TASK_ID = "15929584"    # Entwicklung
HOURS_PER_DAY = 8

# Environment Variables
GITLAB_TOKEN = os.getenv("GITLAB_TOKEN")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
HARVEST_PAT = os.getenv("HARVEST_PAT")


def get_gitlab_activity(target_date: date) -> str:
    """
    Fetches GitLab activity for a given date and returns a summary generated by an AI model.
    """
    if not GITLAB_TOKEN:
        print("Error: No GITLAB_TOKEN provided in environment.", file=sys.stderr)
        sys.exit(1)
    if not OPENROUTER_API_KEY:
        print("Error: No OPENROUTER_API_KEY provided in environment.", file=sys.stderr)
        sys.exit(1)

    after_date = target_date - timedelta(days=1)
    before_date = target_date + timedelta(days=1)

    # 1. Fetch GitLab Events
    try:
        gitlab_url = (
            f"https://gitlab.com/api/v4/users/{GITLAB_USER}/events"
            f"?after={after_date.isoformat()}&before={before_date.isoformat()}&per_page=100"
        )
        headers = {"PRIVATE-TOKEN": GITLAB_TOKEN}
        response = requests.get(gitlab_url, headers=headers, timeout=10)
        response.raise_for_status()
        commit_log = response.json()
    except requests.RequestException as e:
        print(f"Error fetching GitLab activity: {e}", file=sys.stderr)
        return "Error fetching GitLab activity."

    if not commit_log:
        return "No coding activity found."

    # 2. Get AI-generated summary
    try:
        prompt = (
            "Describe the programmer's work based on the commit log in a concise manner. "
            "Only do the task without any introductions and write from the programmer's perspective. "
            "Don't do any formatting. "
            f"{json.dumps(commit_log)}"
        )
        payload = {
            "model": "openai/gpt-oss-20b:free",
            "messages": [{"role": "user", "content": prompt}],
        }
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        }
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
            json=payload,
            timeout=20,
        )
        response.raise_for_status()
        summary = response.json()["choices"][0]["message"]["content"]
        return summary.strip().strip('"')
    except requests.RequestException as e:
        print(f"Error getting AI summary: {e}", file=sys.stderr)
        return "Error generating work summary."
    except (KeyError, IndexError):
        print(f"Error parsing AI response: {response.text}", file=sys.stderr)
        return "Error parsing AI response."


def log_harvest_time(spent_date: date):
    """
    Logs a time entry to Harvest for a specific date.
    """
    if not HARVEST_PAT:
        print("Error: No HARVEST_PAT provided in environment.", file=sys.stderr)
        sys.exit(1)

    iso_date = spent_date.isoformat()
    print(f"Fetching activity for {iso_date}...")
    notes = get_gitlab_activity(spent_date)
    print(f"  -> Notes: {notes}")

    payload = {
        "user_id": HARVEST_USER_ID,
        "project_id": HARVEST_PROJECT_ID,
        "task_id": HARVEST_TASK_ID,
        "spent_date": iso_date,
        "notes": notes,
        "hours": HOURS_PER_DAY,
    }

    try:
        headers = {
            "Authorization": f"Bearer {HARVEST_PAT}",
            "Harvest-Account-Id": HARVEST_ACCOUNT_ID,
            "Content-Type": "application/json",
        }
        response = requests.post(
            "https://api.harvestapp.com/v2/time_entries",
            headers=headers,
            json=payload,
            timeout=10,
        )
        response.raise_for_status()
        print(f"Time entry successfully logged for {iso_date}")
    except requests.RequestException as e:
        print(f"Error logging time to Harvest: {e}", file=sys.stderr)
        if 'response' in locals():
            print(f"Response body: {response.text}", file=sys.stderr)


def validate_iso_date(date_string: str) -> date:
    """Validates that the date string is in YYYY-MM-DD format and returns a date object."""
    try:
        return date.fromisoformat(date_string)
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"Date '{date_string}' is not in ISO 8601 format (YYYY-MM-DD)"
        )


def main():
    """Main script logic to parse arguments and log time."""
    parser = argparse.ArgumentParser(
        description="Log time to Harvest based on GitLab activity.",
        epilog="""Examples:
  %(prog)s                          # Log time for today
  %(prog)s 2025-06-25               # Log time for a specific date
  %(prog)s 2025-06-20 2025-06-25    # Log time for a date range (inclusive)""",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "start_date",
        nargs="?",
        type=validate_iso_date,
        default=date.today(),
        help="Start date in YYYY-MM-DD format. Defaults to today.",
    )
    parser.add_argument(
        "end_date",
        nargs="?",
        type=validate_iso_date,
        help="End date in YYYY-MM-DD format (inclusive). If omitted, only start_date is used.",
    )
    args = parser.parse_args()

    start = args.start_date
    end = args.end_date if args.end_date else start

    if start > end:
        print("Error: Start date must be before or the same as the end date.", file=sys.stderr)
        sys.exit(1)

    current_date = start
    while current_date <= end:
        log_harvest_time(current_date)
        current_date += timedelta(days=1)
        if current_date <= end:
            print("-" * 20)


if __name__ == "__main__":
    main()
